#' @export
Slinky$methods(de.by.plate = function(treat, 
                                      control="auto", 
                                      method="cd", 
                                      where_clause=list(),
                                      gold=TRUE, 
                                      inferred=FALSE,
                                      verbose=FALSE, ...) {
  "Calculate differential expression scores, subsetting by plate.
  \\subsection{Parameters}{
  \\itemize{
  \\item{\\code{treat} An ExpressionSet containing the treated samples, or the pert_desc of desired perturbagen. See details. }
  \\item{\\code{conrol} An ExpressionSet containing the control samples, or the pert_desc of desired controls. Default is 'auto'. See details.}
  \\item{\\code{method} Scoring method to use.  Only \\code{cd} is presently supported.}
  \\item{\\code{where_clause} If treat is a pert_desc, further query terms may be specified here (e.g. \\code{pert_type=\"trt_sh\"}).}
  \\item{\\code{gold} Restrict analysis to gold instances as defined by LINCS.  Ignored if treat and control are ExpressionSets.}
  \\item{\\code{inferred} Should the inferred (non-landmark) genes be included in the analysis? Default is FALSE.}
  \\item{\\code{verbos} Do you want to know how things are going? Default is FALSE.}
  \\item{\\code{...} Additional arguments for \\code{method}.}
  }}
  \\subsection{Return Value}{Vectors of scores, one per subset (plate).}
  \\subsection{Details}{This function looks for \\code{rna_plate} in \\code{pData(treat)} and \\code{pData(control)} to slice the 
                        data into subsets, and then performs differential expression analysis on the subsets.
                        The simplest way to go about this.  If a perturbation identifier is provided instead of 
                        an ExpressionSet, the necessary ExpressionSet is constructed by calling this package's \\code{toEset} 
                        function (which requires that you have initialized this class with appropriate clue.io key and location of gctx file). 
                        Note that the control dataset can be automatically generated by the default option of \\code{control=\"auto\"}.  
                        In this case, appropriate same-plate controls are identified for the samples in the treat dataset and loaded.
                        For more complex queries, you can create the requisite ExpressionSets yourself with \\code{toEset}, or 
                        create an ExpressionSets by any other methods, ensuring that \\code{pData(treat)} and \\code{pData(control)} contain the 
                        \\code{rna_plate} variable for subsetting. Note that this function assumes that each plate represented in \\code{treat}
                        is also represented in \\code{control}}"
  
  if(class(treat) == "character") {
    where_clause$pert_desc = treat
    if(gold) {
      where_clause$is_gold = TRUE;
    }
    fields <- c("rna_plate", "distil_id")
    if(verbose) message("Loading data for 'treat' group.")
    treat <- .self$toEset(where_clause=where_clause, fields=fields, verbose=verbose)
    if(verbose) message(paste0("\nLoaded ", ncol(treat), " treated samples."))
    
  } else if(class(treat) != "ExpressionSet") {

    stop("de.by.plate expects either the pert_desc of the perturbagen or an Expression Set for the 'treat' dataset")
    
  }
  if(control == "auto") {
    if(verbose) message("\nLocating and loading control samples.")
    ids <- .self$info.controls(Biobase::pData(treat)$distil_id, verbose=verbose)$distil_id
    control <- .self$toEset(index=list(1:978, which(.self$colnames() %in% ids)))
    if(verbose) message(paste0("\nLoaded ", ncol(control), " control samples."))
    
  } else if(class(control) == "character") {
    
    where_clause <- list(pert_desc = control)
    if(gold) {
      where_clause$is_gold = TRUE;
    }
    fields <- c("rna_plate", "distil_id")
    if(verbose) message("Loading data for 'control' group.")
    control <- .self$toEset(where_clause=where_clause, fields=fields, verbose=verbose)
    if(verbose) message(paste0("Loaded ", ncol(control), " control samples."))
    
  } else if(class(control) != "ExpressionSet") {
    
    stop("de.by.plate expects either the pert_desc of the perturbagen or an Expression Set for the 'control' dataset")
    
  }
  
  if(method == "cd") {
    if(verbose) message("Calculating CD scores.")
    cds <- Biobase::pData(treat) %>% 
      dplyr::group_by(rna_plate) %>% 
      dplyr::do(cd = .self$chDir(treat[, which(treat$rna_plate %in% .$rna_plate)], 
                          control[, which(control$rna_plate %in% .$rna_plate)])) 

    # flatten structure to matrix
    cds <- do.call(cbind, cds$cd) %>%
      `colnames<-`(cds$rna_plate)
    return(cds)
  } else {
    stop("Only 'cd' is currently supported as a method for diffExpByPlate")
  }
})

Slinky$methods(score = function(data, method, ...) {
  "Provide a uniform interface to scoring functions.
  \\subsection{Parameters}{
  \\itemize{
  \\item{\\code{data} Matrix of expression data to score. }
  \\item{\\code{method} Scoring method to use.  Only \\code{ks} is presently supported.}
  \\item{\\code{...} Additional arguments for \\code{method}.}
  }}
  \\subsection{Return Value}{Vectors of scores, one per column of data}"
  if(method == "ks") {
    return(.self$.ks(data, ...))
  } else if(method == "xsum") {
    return(.self$.xsum(data, ...))
  } else {
    return(NULL)
  }
})

Slinky$methods(.ks = function(data, up, down, plot=FALSE) {
  "Calculate KS based enrichment statistic (CMAP method, Lamb, et al.)
  \\subsection{Parameters}{
  \\itemize{
  \\item{\\code{data} Matrix of expression data to score. }
  \\item{\\code{up} List of upregulated gene ids (must match rownames(data)).}
  \\item{\\code{down} List of downregulated gene ids (must match rownames(data)).}
  \\item{\\code{plot} Whether to plot GSEA style plot for each column (not implemented).}
  }}
  \\subsection{Return Value}{Vectors of scores, all in (0,1), one per column of data}"
  f <- function(ix, n) {
    sc <- rep(-1/(n-length(ix)), n)
    # account for ties
    ix <- round(ix)
    sc[ix] <- 0
    for(i in ix) {
      sc[i] <- sc[i] + 1/length(ix) 
    }
    sc <- cumsum(sc) 
    if(max(sc) > -min(sc)) {
      return(max(sc))
    } else {
      return(min(sc))
    }
  }
  data <- apply(-data, 2, rank)
  up <- which(base::rownames(data) %in% up)
  down <- which(base::rownames(data) %in% down)
  apply(data, 2, function(x) {
    u <- f(x[up], length(x))
    d <- f(x[down], length(x))
    if(sign(u) == sign(d)) {
      return(0)
    } else {
      return((0.5*(abs(u) + abs(d))) * sign(u))
    }
  })
})

Slinky$methods(.xsum = function(data, up, down, n=100) {
  "Calculate Extreme Sum stat (Agerwal et al.))
  \\subsection{Parameters}{
  \\itemize{
  \\item{\\code{data} Matrix of expression data to score. }
  \\item{\\code{up} List of upregulated gene ids (must match rownames(data)).}
  \\item{\\code{down} List of downregulated gene ids (must match rownames(data)).}
  \\item{\\code{n} How many genes to consider for scoring among up and down regulated genes in each column of the data matrix.}
  }}
  \\subsection{Return Value}{Vectors of scores, all in one per column of data}"
  
  up.ix <- which(base::rownames(data) %in% up)
  down.ix <- which(base::rownames(data) %in% down)
  f <- function(a) {
    a_r <- rank(a)
    changed <- a * (a_r > ( length(a_r) - n) | a_r < n)
    sum(changed[up.ix]) - sum(changed[down.ix], na.rm=TRUE)  
  }
  apply(data, 2, f)
})