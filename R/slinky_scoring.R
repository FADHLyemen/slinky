#' @export
Slinky$methods(diffexp = function(treat,
                                control = "auto",
                                method = "cd",
                                split_by_plate = TRUE,
                                where_clause = list(),
                                gold = TRUE,
                                inferred = FALSE,
                                verbose = FALSE, ...) {
    "Calculate differential expression scores, subsetting by plate.
    \\subsection{Parameters}{
    \\itemize{
        \\item{\\code{treat} An ExpressionSet containing the treated samples,
            or the pert_desc of desired perturbagen. See details. }
        \\item{\\code{conrol} An ExpressionSet containing the control samples,
            or the pert_desc of desired controls. Default is 'auto'. See
            details.}
        \\item{\\code{method} Scoring method to use.  Only \\code{cd} is
            presently supported.}
        \\item{\\code{split_by_plate} Should the analysis be split by plate?
            This is one way to control for batch effects, but requires at least
            two treated sample and two control samples on each plate in the
            dataset.}
        \\item{\\code{where_clause} If treat is a pert_desc, further query
            terms may be specified here (e.g. \\code{pert_type=\"trt_sh\"}).}
        \\item{\\code{gold} Restrict analysis to gold instances as defined by
            LINCS. Ignored if treat and control are ExpressionSets.}
        \\item{\\code{inferred} Should the inferred (non-landmark) genes be
            included in the analysis? Default is FALSE.}
        \\item{\\code{verbos} Do you want to know how things are going?
            Default is FALSE.}
        \\item{\\code{...} Additional arguments for \\code{method}.}
    }}
    \\subsection{Return Value}{Vectors of scores, one per subset (plate).}
    \\subsection{Details}{This function looks for \\code{rna_plate} in
        \\code{pData(treat)} and \\code{pData(control)} to slice the data
        into subsets, and then performs differential expression analysis on
        the subsets. The simplest way to go about this.  If a perturbation
        identifier is provided instead of an ExpressionSet, the necessary
        ExpressionSet is constructed by calling this package's \\code{toEset}
        function (which requires that you have initialized this class with
        appropriate clue.io key and location of gctx file). Note that the
        control dataset can be automatically generated by the default option
        of \\code{control=\"auto\"}. In this case, appropriate same-plate
        controls are identified for the samples in the treat dataset and
        loaded. For more complex queries, you can create the requisite
        ExpressionSets yourself with \\code{toEset}, or create an
        ExpressionSets by any other methods, ensuring that
        \\code{pData(treat)} and \\code{pData(control)} contain the
        \\code{rna_plate} variable for subsetting. Note that this function
        assumes that each plate represented in \\code{treat} is also
        represented in \\code{control}}"

    if (class(treat) == "character") {
        where_clause$pert_iname = treat

        if (gold) {
            where_clause$is_gold = TRUE
        }

        fields <- c("rna_plate", "distil_id")
        if (verbose)
            message("Loading data for 'treat' group.")
        treat <- .self$toEset(where_clause = where_clause,
                                fields = fields,
                                verbose = verbose)
        if (verbose)
            message(paste0("\nLoaded ", ncol(treat), " treated samples."))

    } else if (class(treat) != "ExpressionSet") {
        stop("de.by.plate expects either the pert_desc of the perturbagen ",
            "or an Expression Set for the 'treat' dataset")
    }

    if (control == "auto") {

        if (verbose) message("\nLocating and loading control samples.")
        ids <- .self$controls(Biobase::pData(treat)$distil_id,
                                    verbose = verbose)$distil_id
        control <- .self$toEset(index = list(1:978,
                                             which(.self$colnames() %in% ids)))
        if (verbose)
            message(paste0("\nLoaded ", ncol(control), " control samples."))

    } else if (class(control) == "character") {

        where_clause <- list(pert_desc = control)
        if (gold) where_clause$is_gold = TRUE
        fields <- c("rna_plate", "distil_id")

        if (verbose) message("Loading data for 'control' group.")

        control <- .self$toEset(where_clause = where_clause,
            fields = fields, verbose = verbose)

        if (verbose)
            message(paste0("Loaded ", ncol(control), " control samples."))

    } else if (class(control) != "ExpressionSet") {
        stop("de.by.plate expects either the pert_desc of the perturbagen or",
            "an Expression Set for the 'control' dataset")
    }
    if (method == "cd") {
        if (verbose) message("Calculating CD scores.")
        if(split_by_plate) {
            cds <- Biobase::pData(treat) %>%
                dplyr::group_by(rna_plate) %>%
                dplyr::do(cd =
                              .self$chDir(treat[, which(treat$rna_plate %in% .$rna_plate)],
                                          control[, which(control$rna_plate %in% .$rna_plate)]))
            # flatten structure to matrix
            cds <- do.call(cbind, cds$cd) %>% `colnames<-`(cds$rna_plate)
        } else {
            cds = .self$chDir(treat, control)
        }
        return(cds)
    } else {
        stop("Only 'cd' is currently supported as a method for diffExpByPlate")
    }
})

